import { ref as k, computed as O, watch as L, nextTick as Ie, onBeforeUnmount as ae, reactive as se, onMounted as Le, defineComponent as ne, inject as J, toRef as Ze, unref as h, withDirectives as he, openBlock as I, createElementBlock as N, normalizeClass as we, normalizeStyle as be, withKeys as Ke, withModifiers as Te, createBlock as z, Transition as Me, mergeProps as G, toHandlers as Se, withCtx as Q, createCommentVNode as $, createVNode as Pe, createElementVNode as Y, renderSlot as re, vShow as Oe, Teleport as qe, normalizeProps as xe, guardReactiveProps as _e, useAttrs as Je, getCurrentInstance as Qe, markRaw as q, shallowRef as eo, Fragment as oo, renderList as Ce, resolveDynamicComponent as le, createSlots as no, shallowReactive as Z } from "vue";
import { useEventListener as R, tryOnUnmounted as to, isString as ie } from "@vueuse/core";
import { useFocusTrap as lo } from "@vueuse/integrations/useFocusTrap";
const ue = {
  /**
   * @description An uniq name for the open/close a modal via vfm.open/vfm.close APIs.
   * @default `undefined`
   * @example Symbol: `Symbol('MyModal')`
   * @example String: `'AUniqString'`
   * @example Number: `300`
   */
  modalId: {
    type: [String, Number, Symbol],
    default: void 0
  },
  /**
   * @description Display the modal or not.
   * @default `undefined`
   * @example
   * ```js
   * const showModal = ref(false)
   * v-model="showModal"
   * ```
   */
  modelValue: {
    type: Boolean,
    default: void 0
  },
  /**
   * @description Render the modal via `if` or `show`.
   * @default `'if'`
   * @example
   * ```js
   * displayDirective: 'if'
   * ```
   * @example
   * ```js
   * displayDirective: 'show'
   * ```
   */
  displayDirective: {
    type: String,
    default: "if",
    validator: (e) => ["if", "show"].includes(e)
  },
  /**
   * @description Hide the overlay or not.
   * @default `undefined`
   * @example
   * ```js
   * hideOverlay="true"
   * ```
   */
  hideOverlay: {
    type: Boolean,
    default: void 0
  },
  /**
   * @description Customize the overlay transition.
   * @default `undefined`
   */
  overlayTransition: {
    type: [String, Object],
    default: void 0
  },
  /**
   * @description Customize the content transition.
   * @default `undefined`
   */
  contentTransition: {
    type: [String, Object],
    default: void 0
  },
  /**
   * @description Bind class to vfm__overlay.
   * @default `undefined`
   */
  overlayClass: {
    type: void 0,
    default: void 0
  },
  /**
   * @description Bind class to vfm__content.
   * @default `undefined`
   */
  contentClass: {
    type: void 0,
    default: void 0
  },
  /**
   * @description Bind style to vfm__overlay.
   * @default `undefined`
   */
  overlayStyle: {
    type: [String, Object, Array],
    default: void 0
  },
  /**
   * @description Bind style to vfm__content.
   * @default `undefined`
   */
  contentStyle: {
    type: [String, Object, Array],
    default: void 0
  },
  /**
   * @description Is it allow to close the modal by clicking the overlay.
   * @default `true`
   */
  clickToClose: {
    type: Boolean,
    default: !0
  },
  /**
   * @description Is it allow to close the modal by keypress `esc`.
   * @default `true`
   */
  escToClose: {
    type: Boolean,
    default: !0
  },
  /**
   * @description Is it allow to click outside of the vfm__content when the modal is opened
   * @default `'non-interactive'`
   */
  background: {
    type: String,
    default: "non-interactive",
    validator: (e) => ["interactive", "non-interactive"].includes(e)
  },
  /**
   * @description
   * * Use `{ disabled: true }` to disable the focusTrap.
   * * Checkout the createOptions type here https://github.com/focus-trap/focus-trap for more.
   * @default `{ allowOutsideClick: true }`
   */
  focusTrap: {
    type: [Boolean, Object],
    default: () => ({
      allowOutsideClick: !0
    })
  },
  /**
   * @description Lock body scroll or not when the modal is opened.
   * @default `true`
   */
  lockScroll: {
    type: Boolean,
    default: !0
  },
  /**
   * @description Define how to increase the zIndex when there are nested modals
   * @default `({ index }) => 1000 + 2 * index`
   */
  zIndexFn: {
    type: Function,
    default: ({ index: e }) => 1e3 + 2 * e
  },
  /**
   * @description The direction of swiping to close the modal
   * @default `none`
   * @example
   * Set swipeToClose="none" to disable swiping to close
   * ```js
   * swipeToClose="none"
   * ```
   */
  swipeToClose: {
    type: String,
    default: "none",
    validator: (e) => ["none", "up", "right", "down", "left"].includes(e)
  },
  /**
   * @description Threshold for swipe to close
   * @default `0`
   */
  threshold: {
    type: Number,
    default: 0
  },
  /**
   * @description If set `:showSwipeBanner="true"`, only allow clicking `swipe-banner` slot to swipe to close
   * @default `undefined`
   * @example
   * ```js
   * swipeToClose="right"
   * :showSwipeBanner="true"
   * ```
   * ```html
   * <VueFinalModal
   *   ...
   *   swipeToClose="right"
   *   :showSwipeBanner="true"
   * >
   *   <template #swipe-banner>
   *     <div style="position: absolute; height: 100%; top: 0; left: 0; width: 10px;" />
   *   </template>
   *   ...modal content
   * </VueFinalModal>
   * ```
   */
  showSwipeBanner: {
    type: Boolean,
    default: void 0
  },
  /**
   * @description When set `:preventNavigationGestures="true"`, there will be two invisible bars for prevent navigation gestures including swiping back/forward on mobile webkit. For example: Safari mobile.
   * @default `undefined`
   * @example
   * Set preventNavigationGestures="true" to prevent Safari navigation gestures including swiping back/forward.
   * ```js
   * :preventNavigationGestures="true"
   * ```
   */
  preventNavigationGestures: {
    type: Boolean,
    default: void 0
  }
};
function ge(e = !1) {
  const o = k(e), n = k(o.value ? 0 : void 0);
  return [o, n, {
    beforeEnter() {
      n.value = 1;
    },
    afterEnter() {
      n.value = 0;
    },
    beforeLeave() {
      n.value = 3;
    },
    afterLeave() {
      n.value = 2;
    }
  }];
}
function so(e, o) {
  const { modelValueLocal: n, onEntering: l, onEnter: u, onLeaving: i, onLeave: s } = o, t = k(n.value), [r, f, y] = ge(t.value), [d, c, v] = ge(t.value), C = O(() => typeof e.contentTransition == "string" ? { name: e.contentTransition } : { ...e.contentTransition }), B = O(() => typeof e.overlayTransition == "string" ? { name: e.overlayTransition } : { ...e.overlayTransition }), g = O(
    () => (e.hideOverlay || c.value === 2) && f.value === 2
    /* Leave */
  );
  L(
    g,
    (x) => {
      x && (t.value = !1);
    }
  ), L(f, (x) => {
    switch (x) {
      case 1:
        return l == null ? void 0 : l();
      case 0:
        return u == null ? void 0 : u();
      case 3:
        return i == null ? void 0 : i();
      case 2:
        return s == null ? void 0 : s();
    }
  });
  async function M() {
    t.value = !0, await Ie(), r.value = !0, d.value = !0;
  }
  function P() {
    r.value = !1, d.value = !1;
  }
  return {
    visible: t,
    contentVisible: r,
    contentListeners: y,
    contentTransition: C,
    overlayVisible: d,
    overlayListeners: v,
    overlayTransition: B,
    enterTransition: M,
    leaveTransition: P
  };
}
function ro(e, o, n) {
  const { vfmRootEl: l, vfmContentEl: u, visible: i, modelValueLocal: s } = n, t = k();
  function r() {
    i.value && e.escToClose && (s.value = !1);
  }
  function f(d) {
    t.value = d == null ? void 0 : d.target;
  }
  function y() {
    var d;
    t.value === l.value && (e.clickToClose ? s.value = !1 : ((d = u.value) == null || d.focus(), o("clickOutside")));
  }
  return {
    onEsc: r,
    onMouseupRoot: y,
    onMousedown: f
  };
}
function ao(e, o) {
  const n = k(!!e.modelValue);
  return L(() => e.modelValue, (l) => {
    n.value = !!l;
  }), L(n, (l) => {
    l !== e.modelValue && o("update:modelValue", l);
  }), {
    modelValueLocal: n
  };
}
function io(e, o) {
  if (e.focusTrap === !1)
    return {
      focus() {
      },
      blur() {
      }
    };
  const { focusEl: n } = o, { hasFocus: l, activate: u, deactivate: i } = lo(n, e.focusTrap);
  function s() {
    requestAnimationFrame(() => {
      u();
    });
  }
  function t() {
    l.value && i();
  }
  return { focus: s, blur: t };
}
let de = !1;
if (typeof window < "u") {
  const e = {
    get passive() {
      de = !0;
    }
  };
  window.addEventListener("testPassive", null, e), window.removeEventListener("testPassive", null, e);
}
const De = typeof window < "u" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1);
let H = [], ee = !1, _ = 0, Fe = -1, U, W;
const uo = (e) => {
  if (!e || e.nodeType !== Node.ELEMENT_NODE)
    return !1;
  const o = window.getComputedStyle(e);
  return ["auto", "scroll"].includes(o.overflowY) && e.scrollHeight > e.clientHeight;
}, co = (e, o) => !(e.scrollTop === 0 && o < 0 || e.scrollTop + e.clientHeight + o >= e.scrollHeight && o > 0), fo = (e) => {
  const o = [];
  for (; e; ) {
    if (o.push(e), e.classList.contains("vfm"))
      return o;
    e = e.parentElement;
  }
  return o;
}, vo = (e, o) => {
  let n = !1;
  return fo(e).forEach((u) => {
    uo(u) && co(u, o) && (n = !0);
  }), n;
}, Ae = (e) => H.some(() => vo(e, -_)), oe = (e) => {
  const o = e || window.event;
  return Ae(o.target) || o.touches.length > 1 ? !0 : (o.preventDefault && o.preventDefault(), !1);
}, po = (e) => {
  if (W === void 0) {
    const o = !!e && e.reserveScrollBarGap === !0, n = window.innerWidth - document.documentElement.clientWidth;
    if (o && n > 0) {
      const l = parseInt(getComputedStyle(document.body).getPropertyValue("padding-right"), 10);
      W = document.body.style.paddingRight, document.body.style.paddingRight = `${l + n}px`;
    }
  }
  U === void 0 && (U = document.body.style.overflow, document.body.style.overflow = "hidden");
}, mo = () => {
  W !== void 0 && (document.body.style.paddingRight = W, W = void 0), U !== void 0 && (document.body.style.overflow = U, U = void 0);
}, yo = (e) => e ? e.scrollHeight - e.scrollTop <= e.clientHeight : !1, ho = (e, o) => (_ = e.targetTouches[0].clientY - Fe, Ae(e.target) ? !1 : o && o.scrollTop === 0 && _ > 0 || yo(o) && _ < 0 ? oe(e) : (e.stopPropagation(), !0)), wo = (e, o) => {
  if (!e) {
    console.error(
      "disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices."
    );
    return;
  }
  if (H.some((l) => l.targetElement === e))
    return;
  const n = {
    targetElement: e,
    options: o || {}
  };
  H = [...H, n], De ? (e.ontouchstart = (l) => {
    l.targetTouches.length === 1 && (Fe = l.targetTouches[0].clientY);
  }, e.ontouchmove = (l) => {
    l.targetTouches.length === 1 && ho(l, e);
  }, ee || (document.addEventListener("touchmove", oe, de ? { passive: !1 } : void 0), ee = !0)) : po(o);
}, bo = (e) => {
  if (!e) {
    console.error(
      "enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices."
    );
    return;
  }
  H = H.filter((o) => o.targetElement !== e), De ? (e.ontouchstart = null, e.ontouchmove = null, ee && H.length === 0 && (document.removeEventListener("touchmove", oe, de ? { passive: !1 } : void 0), ee = !1)) : H.length || mo();
};
function To(e, o) {
  const { lockScrollEl: n } = o;
  L(() => e.lockScroll, (i) => {
    i ? u() : l();
  }), ae(() => {
    l();
  });
  function l() {
    n.value && bo(n.value);
  }
  function u() {
    e.lockScroll && n.value && wo(n.value, {
      reserveScrollBarGap: !0,
      allowTouchMove: (i) => {
        for (; i && i !== document.body; ) {
          if (i.getAttribute("vfm-scroll-lock-ignore") !== null)
            return !0;
          i = i.parentElement;
        }
        return !1;
      }
    });
  }
  return {
    enableBodyScroll: l,
    disableBodyScroll: u
  };
}
function Mo(e) {
  function o(n) {
    switch (n) {
      case "beforeOpen":
        e(n);
        break;
      case "beforeClose":
        e(n);
        break;
      case "opened":
        e(n);
        break;
      case "closed":
        e(n);
        break;
    }
  }
  return {
    emitEvent: o
  };
}
function So(e) {
  const o = k();
  function n(u) {
    var i;
    o.value = (i = e.zIndexFn) == null ? void 0 : i.call(e, { index: u <= -1 ? 0 : u });
  }
  function l() {
    o.value = void 0;
  }
  return {
    zIndex: o,
    refreshZIndex: n,
    resetZIndex: l
  };
}
const Oo = (e) => (...o) => {
  e && (e == null || e(...o), e = null);
}, D = () => {
};
function K(e, o, n) {
  return e > n ? n : e < o ? o : e;
}
const Ee = (e) => {
  if (e instanceof MouseEvent) {
    const { clientX: o, clientY: n } = e;
    return { x: o, y: n };
  } else {
    const { clientX: o, clientY: n } = e.targetTouches[0];
    return { x: o, y: n };
  }
};
function Co(e) {
  if (!e)
    return !1;
  let o = !1;
  const n = {
    get passive() {
      return o = !0, !1;
    }
  };
  return e.addEventListener("x", D, n), e.removeEventListener("x", D), o;
}
function go(e, {
  threshold: o = 0,
  onSwipeStart: n,
  onSwipe: l,
  onSwipeEnd: u,
  passive: i = !0
}) {
  const s = se({ x: 0, y: 0 }), t = se({ x: 0, y: 0 }), r = O(() => s.x - t.x), f = O(() => s.y - t.y), { max: y, abs: d } = Math, c = O(
    () => y(d(r.value), d(f.value)) >= o
  ), v = k(!1), C = O(() => c.value ? d(r.value) > d(f.value) ? r.value > 0 ? "left" : "right" : f.value > 0 ? "up" : "down" : "none"), B = (p, w) => {
    s.x = p, s.y = w;
  }, g = (p, w) => {
    t.x = p, t.y = w;
  };
  let M, P;
  function x(p) {
    M.capture && !M.passive && p.preventDefault();
    const { x: w, y: A } = Ee(p);
    B(w, A), g(w, A), n == null || n(p), P = [
      R(e, "mousemove", E, M),
      R(e, "touchmove", E, M),
      R(e, "mouseup", a, M),
      R(e, "touchend", a, M),
      R(e, "touchcancel", a, M)
    ];
  }
  function E(p) {
    const { x: w, y: A } = Ee(p);
    g(w, A), !v.value && c.value && (v.value = !0), v.value && (l == null || l(p));
  }
  function a(p) {
    v.value && (u == null || u(p, C.value)), v.value = !1, P.forEach((w) => w());
  }
  let m = [];
  return Le(() => {
    const p = Co(window == null ? void 0 : window.document);
    i ? M = p ? { passive: !0 } : { capture: !1 } : M = p ? { passive: !1, capture: !0 } : { capture: !0 }, m = [
      R(e, "mousedown", x, M),
      R(e, "touchstart", x, M)
    ];
  }), {
    isSwiping: v,
    direction: C,
    coordsStart: s,
    coordsEnd: t,
    lengthX: r,
    lengthY: f,
    stop: () => {
      m.forEach((p) => p()), P.forEach((p) => p());
    }
  };
}
function Eo(e, o) {
  const { vfmContentEl: n, modelValueLocal: l } = o, u = 0.1, i = 300, s = k(), t = O(() => {
    if (!(e.swipeToClose === void 0 || e.swipeToClose === "none"))
      return e.showSwipeBanner ? s.value : n.value;
  }), r = k(0), f = k(!0);
  let y = D, d = !0, c, v = !1;
  const { lengthX: C, lengthY: B, direction: g, isSwiping: M } = go(t, {
    threshold: e.threshold,
    onSwipeStart(a) {
      y = R(document, "selectionchange", () => {
        var m;
        f.value = (m = window.getSelection()) == null ? void 0 : m.isCollapsed;
      }), c = new Date().getTime(), v = E(a == null ? void 0 : a.target);
    },
    onSwipe() {
      var a, m, V, p;
      if (v && f.value && g.value === e.swipeToClose) {
        if (g.value === "up") {
          const w = K(Math.abs(B.value || 0), 0, ((a = t.value) == null ? void 0 : a.offsetHeight) || 0) - (e.threshold || 0);
          r.value = w;
        } else if (g.value === "down") {
          const w = K(Math.abs(B.value || 0), 0, ((m = t.value) == null ? void 0 : m.offsetHeight) || 0) - (e.threshold || 0);
          r.value = -w;
        } else if (g.value === "right") {
          const w = K(Math.abs(C.value || 0), 0, ((V = t.value) == null ? void 0 : V.offsetWidth) || 0) - (e.threshold || 0);
          r.value = -w;
        } else if (g.value === "left") {
          const w = K(Math.abs(C.value || 0), 0, ((p = t.value) == null ? void 0 : p.offsetWidth) || 0) - (e.threshold || 0);
          r.value = w;
        }
      }
    },
    onSwipeEnd(a, m) {
      if (y(), !f.value) {
        f.value = !0;
        return;
      }
      const V = new Date().getTime(), p = m === e.swipeToClose, w = (() => {
        var j, X;
        if (m === "up" || m === "down")
          return Math.abs((B == null ? void 0 : B.value) || 0) > u * (((j = t.value) == null ? void 0 : j.offsetHeight) || 0);
        if (m === "left" || m === "right")
          return Math.abs((C == null ? void 0 : C.value) || 0) > u * (((X = t.value) == null ? void 0 : X.offsetWidth) || 0);
      })(), A = V - c <= i;
      if (d && v && p && (w || A)) {
        l.value = !1;
        return;
      }
      r.value = 0;
    }
  }), P = O(() => {
    if (e.swipeToClose === "none")
      return;
    const a = (() => {
      switch (e.swipeToClose) {
        case "up":
        case "down":
          return "translateY";
        case "left":
        case "right":
          return "translateX";
      }
    })();
    return {
      class: { "vfm-bounce-back": !M.value },
      style: { transform: `${a}(${-r.value}px)` }
    };
  });
  L(
    () => f.value,
    (a) => {
      a || (r.value = 0);
    }
  ), L(
    () => l.value,
    (a) => {
      a && (r.value = 0);
    }
  ), L(
    () => r.value,
    (a, m) => {
      switch (e.swipeToClose) {
        case "down":
        case "right":
          d = a < m;
          break;
        case "up":
        case "left":
          d = a > m;
          break;
      }
    }
  );
  function x(a) {
    e.preventNavigationGestures && a.preventDefault();
  }
  function E(a) {
    const m = a == null ? void 0 : a.tagName;
    if (!m || ["INPUT", "TEXTAREA"].includes(m))
      return !1;
    const V = (() => {
      switch (e.swipeToClose) {
        case "up":
          return (a == null ? void 0 : a.scrollTop) + (a == null ? void 0 : a.clientHeight) === (a == null ? void 0 : a.scrollHeight);
        case "left":
          return (a == null ? void 0 : a.scrollLeft) + (a == null ? void 0 : a.clientWidth) === (a == null ? void 0 : a.scrollWidth);
        case "down":
          return (a == null ? void 0 : a.scrollTop) === 0;
        case "right":
          return (a == null ? void 0 : a.scrollLeft) === 0;
        default:
          return !1;
      }
    })();
    return a === t.value ? V : V && E(a == null ? void 0 : a.parentElement);
  }
  return {
    vfmContentEl: n,
    swipeBannerEl: s,
    bindSwipe: P,
    onTouchStartSwipeBanner: x
  };
}
const ce = Symbol("vfm"), fe = Symbol("internalVfm"), Vo = /* @__PURE__ */ ne({
  __name: "CoreModal",
  props: ue,
  emits: ["update:modelValue", "beforeOpen", "opened", "beforeClose", "closed", "clickOutside"],
  setup(e, { emit: o }) {
    const n = e, { modals: l, openedModals: u } = J(ce, {
      modals: [],
      openedModals: []
    }), {
      openLastOverlay: i,
      moveToLastOpenedModals: s,
      deleteFromOpenedModals: t,
      moveToLastOpenedModalOverlays: r,
      deleteFromOpenedModalOverlays: f,
      deleteFromModals: y
    } = J(fe, {
      openLastOverlay: D,
      moveToLastOpenedModals: D,
      deleteFromOpenedModals: D,
      moveToLastOpenedModalOverlays: D,
      deleteFromOpenedModalOverlays: D,
      deleteFromModals: D
    }), d = k(), c = k(), { focus: v, blur: C } = io(n, { focusEl: d }), { zIndex: B, refreshZIndex: g, resetZIndex: M } = So(n), { enableBodyScroll: P, disableBodyScroll: x } = To(n, { lockScrollEl: d }), { modelValueLocal: E } = ao(n, o), { emitEvent: a } = Mo(o);
    let m = D;
    const {
      visible: V,
      contentVisible: p,
      contentListeners: w,
      contentTransition: A,
      overlayVisible: j,
      overlayListeners: X,
      overlayTransition: He,
      enterTransition: Ne,
      leaveTransition: je
    } = so(n, {
      modelValueLocal: E,
      onEnter() {
        v(), x(), a("opened"), m("opened");
      },
      onLeave() {
        t(Ue()), M(), a("closed"), m("closed");
      }
    }), { onEsc: Ye, onMouseupRoot: $e, onMousedown: ve } = ro(n, o, { vfmRootEl: d, vfmContentEl: c, visible: V, modelValueLocal: E }), {
      swipeBannerEl: ze,
      bindSwipe: Ge,
      onTouchStartSwipeBanner: pe
    } = Eo(n, { vfmContentEl: c, modelValueLocal: E }), me = Ze(n, "hideOverlay"), F = O(() => ({
      modalId: n.modalId,
      hideOverlay: me,
      overlayVisible: j,
      focus: v,
      toggle(b) {
        return new Promise((T) => {
          m = Oo((Xe) => T(Xe));
          const S = typeof b == "boolean" ? b : !E.value;
          E.value = S, o("update:modelValue", S);
        });
      }
    }));
    function Ue() {
      return F;
    }
    const te = O(() => u.indexOf(F));
    L(() => [n.zIndexFn, te.value], () => {
      V.value && g(te.value);
    }), Le(() => {
      l.push(F);
    }), E.value && ye(), L(E, (b) => {
      b ? ye() : We();
    });
    async function ye() {
      a("beforeOpen"), s(F), r(F), g(te.value), i(), Ne();
    }
    function We() {
      a("beforeClose"), P(), f(F), i(), C(), je();
    }
    return ae(() => {
      P(), y(F), t(F), f(F), C(), i();
    }), (b, T) => b.displayDirective !== "if" || h(V) ? he((I(), N("div", {
      key: 0,
      ref_key: "vfmRootEl",
      ref: d,
      class: we(["vfm vfm--fixed vfm--inset", { "vfm--prevent-none": b.background === "interactive" }]),
      style: be({ zIndex: h(B) }),
      role: "dialog",
      "aria-modal": "true",
      onKeydown: T[7] || (T[7] = Ke(() => h(Ye)(), ["esc"])),
      onMouseup: T[8] || (T[8] = Te(() => h($e)(), ["self"])),
      onMousedown: T[9] || (T[9] = Te((S) => h(ve)(S), ["self"]))
    }, [
      h(me) ? $("", !0) : (I(), z(Me, G({ key: 0 }, h(He), { appear: "" }, Se(h(X))), {
        default: Q(() => [
          h(j) ? (I(), N("div", {
            key: 0,
            class: we(["vfm__overlay vfm--overlay vfm--absolute vfm--inset vfm--prevent-none", b.overlayClass]),
            style: be(b.overlayStyle),
            "aria-hidden": "true"
          }, null, 6)) : $("", !0)
        ]),
        _: 1
      }, 16)),
      Pe(Me, G(h(A), { appear: "" }, Se(h(w))), {
        default: Q(() => [
          he(Y("div", G({
            ref_key: "vfmContentEl",
            ref: c,
            class: ["vfm__content vfm--outline-none", [b.contentClass, { "vfm--prevent-auto": b.background === "interactive" }]],
            style: b.contentStyle,
            tabindex: "0"
          }, h(Ge), {
            onMousedown: T[6] || (T[6] = () => h(ve)())
          }), [
            re(b.$slots, "default"),
            b.showSwipeBanner ? (I(), N("div", {
              key: 0,
              ref_key: "swipeBannerEl",
              ref: ze,
              class: "vfm-swipe-banner-container",
              onTouchstart: T[2] || (T[2] = (S) => h(pe)(S))
            }, [
              re(b.$slots, "swipe-banner", {}, () => [
                Y("div", {
                  class: "vfm-swipe-banner-back",
                  onTouchstart: T[0] || (T[0] = (S) => b.swipeToClose === "left" && S.preventDefault())
                }, null, 32),
                Y("div", {
                  class: "vfm-swipe-banner-forward",
                  onTouchstart: T[1] || (T[1] = (S) => b.swipeToClose === "right" && S.preventDefault())
                }, null, 32)
              ])
            ], 544)) : !b.showSwipeBanner && b.preventNavigationGestures ? (I(), N("div", {
              key: 1,
              class: "vfm-swipe-banner-container",
              onTouchstart: T[5] || (T[5] = (S) => h(pe)(S))
            }, [
              Y("div", {
                class: "vfm-swipe-banner-back",
                onTouchstart: T[3] || (T[3] = (S) => b.swipeToClose === "left" && S.preventDefault())
              }, null, 32),
              Y("div", {
                class: "vfm-swipe-banner-forward",
                onTouchstart: T[4] || (T[4] = (S) => b.swipeToClose === "right" && S.preventDefault())
              }, null, 32)
            ], 32)) : $("", !0)
          ], 16), [
            [Oe, h(p)]
          ])
        ]),
        _: 3
      }, 16)
    ], 38)), [
      [Oe, b.displayDirective !== "show" || h(V)]
    ]) : $("", !0);
  }
});
const ko = {
  ...ue,
  /**
   * @description Set `null | false` to disable teleport.
   * @default `'body'`
   * @example
   * ```js
   * teleportTo: '#modals'
   * ```
   */
  teleportTo: {
    type: [String, null, Boolean, Object],
    default: "body"
  }
}, Bo = ne({
  inheritAttrs: !1
}), Io = /* @__PURE__ */ ne({
  ...Bo,
  __name: "VueFinalModal",
  props: ko,
  emits: ["update:modelValue", "beforeOpen", "opened", "beforeClose", "closed", "clickOutside"],
  setup(e, { emit: o }) {
    const l = Fo({
      props: e,
      modalProps: ue,
      emit: o
    });
    return (u, i) => (I(), z(qe, {
      to: u.teleportTo ? u.teleportTo : void 0,
      disabled: !u.teleportTo
    }, [
      Pe(Vo, xe(_e(h(l))), {
        default: Q(() => [
          re(u.$slots, "default")
        ]),
        _: 3
      }, 16)
    ], 8, ["to", "disabled"]));
  }
});
function Re() {
  return J(ce);
}
function Lo() {
  return J(fe);
}
function Ve(e, o = Io) {
  const { component: n, slots: l, ...u } = e, i = typeof l > "u" ? {} : Object.fromEntries(Object.entries(l).map(([s, t]) => ie(t) ? [s, t] : "component" in t ? [s, {
    ...t,
    component: q(t.component)
  }] : [s, q(t)]));
  return {
    ...u,
    component: q(n || o),
    slots: i
  };
}
function Yo(e) {
  var t;
  const o = se({
    id: Symbol("useModal"),
    modelValue: !!(e != null && e.defaultModelValue),
    resolveOpened: () => {
    },
    resolveClosed: () => {
    },
    attrs: {},
    ...Ve(e)
  });
  o.context || (Qe() ? o.context = Re() : console.warn("[Vue Final Modal warn] useModal() can only be used inside setup() or functional components."));
  function n() {
    return o.modelValue ? Promise.resolve("[Vue Final Modal] modal is already opened") : (o.modelValue = !0, new Promise((r) => {
      o.resolveOpened = () => r("opened");
    }));
  }
  function l() {
    return o.modelValue ? (o.modelValue = !1, new Promise((r) => {
      o.resolveClosed = () => r("closed");
    })) : Promise.resolve("[Vue Final Modal] modal is already closed");
  }
  function u(r) {
    const { slots: f, ...y } = Ve(r, o.component);
    ke(o, y), f && Object.entries(f).forEach(([d, c]) => {
      const v = o.slots[d];
      ie(v) ? o.slots[d] = c : Be(v) && Be(c) ? ke(v, c) : o.slots[d] = c;
    });
  }
  function i() {
    if (!o.context)
      return;
    const r = o.context.dynamicModals.indexOf(o);
    r !== -1 && o.context.dynamicModals.splice(r, 1);
  }
  const s = {
    options: o,
    open: n,
    close: l,
    patchOptions: u,
    destroy: i
  };
  return (t = s.options.context) == null || t.dynamicModals.push(s.options), to(() => s.destroy()), s;
}
function $o(e) {
  return e;
}
function Po(e, o) {
  return Object.entries(o).forEach(([n, l]) => {
    e[n] = l;
  }), e;
}
function ke(e, o) {
  o.component && (e.component = o.component), o.attrs && Po(e.attrs, o.attrs);
}
function Be(e) {
  return "component" in e || "attrs" in e;
}
function xo(e, o) {
  return Object.keys(o).reduce((n, l) => (n[l] = e[l], n), {});
}
function Do(e) {
  return e ? {
    "onUpdate:modelValue": (o) => e("update:modelValue", o),
    onBeforeClose: () => e("beforeClose"),
    onClosed: () => e("closed"),
    onBeforeOpen: () => e("beforeOpen"),
    onOpened: () => e("opened"),
    /** onClickOutside will only be emitted when clickToClose equal to `false` */
    onClickOutside: () => e("clickOutside")
  } : {};
}
function Fo(e) {
  const { props: o, modalProps: n, emit: l } = e, u = O(() => xo(o, n)), i = Do(l), s = Je();
  return O(() => ({
    ...u.value,
    ...i,
    ...s
  }));
}
const Ao = ["innerHTML"], zo = /* @__PURE__ */ ne({
  __name: "ModalsContainer",
  setup(e) {
    const o = Re(), n = Lo(), l = Symbol("ModalsContainer"), u = O(() => {
      var r;
      return l === ((r = o.modalsContainers.value) == null ? void 0 : r[0]);
    }), i = eo([]);
    function s() {
      i.value = o.dynamicModals.filter((r) => r.modelValue);
    }
    function t(r) {
      r == null || r(), s();
    }
    return L(() => {
      var r;
      return (r = o.dynamicModals) == null ? void 0 : r.map((f) => f.modelValue);
    }, (r, f) => {
      if (!f || r.length !== f.length) {
        s();
        return;
      }
      let y = r.length, d = !1;
      for (; !d && y--; )
        r[y] === !0 && f[y] === !1 && (d = !0);
      d && s();
    }, {
      immediate: !0
    }), o.modalsContainers.value.push(l), ae(() => {
      o.modalsContainers.value = o.modalsContainers.value.filter((r) => r !== l);
    }), (r, f) => h(u) ? (I(!0), N(oo, { key: 0 }, Ce(h(i), (y, d) => (I(), z(le(y.component), G({
      key: y.id
    }, y.attrs, {
      modelValue: y.modelValue,
      "onUpdate:modelValue": (c) => y.modelValue = c,
      onClosed: () => t(() => {
        var c, v;
        return (v = (c = h(n)).resolvedClosed) == null ? void 0 : v.call(c, d);
      }),
      onOpened: () => {
        var c, v;
        return (v = (c = h(n)).resolvedOpened) == null ? void 0 : v.call(c, d);
      }
    }), no({ _: 2 }, [
      Ce(y.slots, (c, v) => ({
        name: v,
        fn: Q(() => [
          h(ie)(c) ? (I(), N("div", {
            key: 0,
            innerHTML: c
          }, null, 8, Ao)) : "component" in c ? (I(), z(le(c.component), xe(G({ key: 1 }, c.attrs)), null, 16)) : (I(), z(le(c), { key: 2 }))
        ])
      }))
    ]), 1040, ["modelValue", "onUpdate:modelValue", "onClosed", "onOpened"]))), 128)) : $("", !0);
  }
});
function Go() {
  const e = Z([]), o = Z([]), n = Z([]), l = Z([]), u = k([]), i = q({
    install(s) {
      s.provide(ce, i), s.config.globalProperties.$vfm = i;
      const t = Ro(i);
      s.provide(fe, t);
    },
    modals: e,
    openedModals: o,
    openedModalOverlays: n,
    dynamicModals: l,
    modalsContainers: u,
    get(s) {
      return e.find((t) => t.value.modalId && s === t.value.modalId);
    },
    toggle(s, t) {
      const r = i.get(s);
      return r == null ? void 0 : r.value.toggle(t);
    },
    open(s) {
      return i.toggle(s, !0);
    },
    close(s) {
      return i.toggle(s, !1);
    },
    closeAll() {
      return Promise.allSettled([o.map((s) => s.value.toggle(!1))]);
    }
  });
  return i;
}
function Ro(e) {
  const { modals: o, openedModals: n, openedModalOverlays: l, dynamicModals: u } = e, i = {
    deleteFromModals(s) {
      const t = o.findIndex((r) => r.value === s.value);
      t !== -1 && o.splice(t, 1);
    },
    moveToLastOpenedModals(s) {
      i.deleteFromOpenedModals(s), n.push(s);
    },
    deleteFromOpenedModals(s) {
      const t = n.findIndex((r) => r.value === s.value);
      t !== -1 && n.splice(t, 1);
    },
    moveToLastOpenedModalOverlays(s) {
      i.deleteFromOpenedModalOverlays(s), l.push(s);
    },
    deleteFromOpenedModalOverlays(s) {
      const t = l.findIndex((r) => r.value === s.value);
      t !== -1 && l.splice(t, 1);
    },
    async openLastOverlay() {
      var s;
      if (await Ie(), l.forEach((t) => t.value.overlayVisible.value = !1), l.length > 0) {
        const t = l[l.length - 1];
        !((s = t.value.hideOverlay) != null && s.value) && (t.value.overlayVisible.value = !0);
      }
    },
    resolvedClosed(s) {
      var t, r;
      (r = (t = u[s]) == null ? void 0 : t.resolveClosed) == null || r.call(t);
    },
    resolvedOpened(s) {
      var t, r;
      (r = (t = u[s]) == null ? void 0 : t.resolveOpened) == null || r.call(t);
    }
  };
  return i;
}
export {
  Vo as CoreModal,
  zo as ModalsContainer,
  Io as VueFinalModal,
  ue as coreModalProps,
  Go as createVfm,
  Yo as useModal,
  $o as useModalSlot,
  Re as useVfm,
  Fo as useVfmAttrs,
  ko as vueFinalModalProps
};
